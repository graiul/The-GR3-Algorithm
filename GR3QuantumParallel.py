# https://qiskit.org/documentation/install.html#install-access-ibm-q-devices-label
# https://stackoverflow.com/questions/59122795/ibmqprovidererror-no-provider-matching-the-criteria
# https://github.com/Qiskit/qiskit-ibmq-provider
# https://qiskit.org/documentation/getting_started.html

# https://github.com/Qiskit/qiskit/blob/master/Qiskit.bib
# @misc{ Qiskit,
#        author = {H{\'e}ctor Abraham and AduOffei and Rochisha Agarwal and Ismail Yunus Akhalwaya and Gadi Aleksandrowicz and Thomas Alexander and Matthew Amy and Eli Arbel and Arijit02 and Abraham Asfaw and Artur Avkhadiev and Carlos Azaustre and AzizNgoueya and Abhik Banerjee and Aman Bansal and Panagiotis Barkoutsos and Ashish Barnawal and George Barron and George S. Barron and Luciano Bello and Yael Ben-Haim and Daniel Bevenius and Arjun Bhobe and Lev S. Bishop and Carsten Blank and Sorin Bolos and Samuel Bosch and Brandon and Sergey Bravyi and Bryce-Fuller and David Bucher and Artemiy Burov and Fran Cabrera and Padraic Calpin and Lauren Capelluto and Jorge Carballo and Gin{\'e}s Carrascal and Adrian Chen and Chun-Fu Chen and Edward Chen and Jielun (Chris) Chen and Richard Chen and Jerry M. Chow and Spencer Churchill and Christian Claus and Christian Clauss and Romilly Cocking and Filipe Correa and Abigail J. Cross and Andrew W. Cross and Simon Cross and Juan Cruz-Benito and Chris Culver and Antonio D. C{\'o}rcoles-Gonzales and Sean Dague and Tareq El Dandachi and Marcus Daniels and Matthieu Dartiailh and DavideFrr and Abd{\'o}n Rodr{\'\i}guez Davila and Anton Dekusar and Delton Ding and Jun Doi and Eric Drechsler and Drew and Eugene Dumitrescu and Karel Dumon and Ivan Duran and Kareem EL-Safty and Eric Eastman and Grant Eberle and Pieter Eendebak and Daniel Egger and Mark Everitt and Paco Mart{\'\i}n Fern{\'a}ndez and Axel Hern{\'a}ndez Ferrera and Romain Fouilland and FranckChevallier and Albert Frisch and Andreas Fuhrer and Bryce Fuller and MELVIN GEORGE and Julien Gacon and Borja Godoy Gago and Claudio Gambella and Jay M. Gambetta and Adhisha Gammanpila and Luis Garcia and Tanya Garg and Shelly Garion and Austin Gilliam and Aditya Giridharan and Juan Gomez-Mosquera and Gonzalo and Salvador de la Puente Gonz{\'a}lez and Jesse Gorzinski and Ian Gould and Donny Greenberg and Dmitry Grinko and Wen Guan and John A. Gunnels and Mikael Haglund and Isabel Haide and Ikko Hamamura and Omar Costa Hamido and Frank Harkins and Vojtech Havlicek and Joe Hellmers and {\L}ukasz Herok and Stefan Hillmich and Hiroshi Horii and Connor Howington and Shaohan Hu and Wei Hu and Junye Huang and Rolf Huisman and Haruki Imai and Takashi Imamichi and Kazuaki Ishizaki and Raban Iten and Toshinari Itoko and JamesSeaward and Ali Javadi and Ali Javadi-Abhari and Wahaj Javed and Jessica and Madhav Jivrajani and Kiran Johns and Scott Johnstun and Jonathan-Shoemaker and Vismai K and Tal Kachmann and Akshay Kale and Naoki Kanazawa and Kang-Bae and Anton Karazeev and Paul Kassebaum and Josh Kelso and Spencer King and Knabberjoe and Yuri Kobayashi and Arseny Kovyrshin and Rajiv Krishnakumar and Vivek Krishnan and Kevin Krsulich and Prasad Kumkar and Gawel Kus and Ryan LaRose and Enrique Lacal and Rapha{\"e}l Lambert and John Lapeyre and Joe Latone and Scott Lawrence and Christina Lee and Gushu Li and Dennis Liu and Peng Liu and Yunho Maeng and Kahan Majmudar and Aleksei Malyshev and Joshua Manela and Jakub Marecek and Manoel Marques and Dmitri Maslov and Dolph Mathews and Atsushi Matsuo and Douglas T. McClure and Cameron McGarry and David McKay and Dan McPherson and Srujan Meesala and Thomas Metcalfe and Martin Mevissen and Andrew Meyer and Antonio Mezzacapo and Rohit Midha and Zlatko Minev and Abby Mitchell and Nikolaj Moll and Jhon Montanez and Gabriel Monteiro and Michael Duane Mooring and Renier Morales and Niall Moran and Mario Motta and MrF and Prakash Murali and Jan M{\"u}ggenburg and David Nadlinger and Ken Nakanishi and Giacomo Nannicini and Paul Nation and Edwin Navarro and Yehuda Naveh and Scott Wyman Neagle and Patrick Neuweiler and Johan Nicander and Pradeep Niroula and Hassi Norlen and NuoWenLei and Lee James O'Riordan and Oluwatobi Ogunbayo and Pauline Ollitrault and Raul Otaolea and Steven Oud and Dan Padilha and Hanhee Paik and Soham Pal and Yuchen Pang and Vincent R. Pascuzzi and Simone Perriello and Anna Phan and Francesco Piro and Marco Pistoia and Christophe Piveteau and Pierre Pocreau and Alejandro Pozas-Kerstjens and Milos Prokop and Viktor Prutyanov and Daniel Puzzuoli and Jes{\'u}s P{\'e}rez and Quintiii and Rafey Iqbal Rahman and Arun Raja and Nipun Ramagiri and Anirudh Rao and Rudy Raymond and Rafael Mart{\'\i}n-Cuevas Redondo and Max Reuter and Julia Rice and Matt Riedemann and Marcello La Rocca and Diego M. Rodr{\'\i}guez and RohithKarur and Max Rossmannek and Mingi Ryu and Tharrmashastha SAPV and SamFerracin and Martin Sandberg and Hirmay Sandesara and Ritvik Sapra and Hayk Sargsyan and Aniruddha Sarkar and Ninad Sathaye and Bruno Schmitt and Chris Schnabel and Zachary Schoenfeld and Travis L. Scholten and Eddie Schoute and Joachim Schwarm and Ismael Faro Sertage and Kanav Setia and Nathan Shammah and Yunong Shi and Adenilton Silva and Andrea Simonetto and Nick Singstock and Yukio Siraichi and Iskandar Sitdikov and Seyon Sivarajah and Magnus Berg Sletfjerding and John A. Smolin and Mathias Soeken and Igor Olegovich Sokolov and Igor Sokolov and SooluThomas and Starfish and Dominik Steenken and Matt Stypulkoski and Shaojun Sun and Kevin J. Sung and Hitomi Takahashi and Tanvesh Takawale and Ivano Tavernelli and Charles Taylor and Pete Taylour and Soolu Thomas and Mathieu Tillet and Maddy Tod and Miroslav Tomasik and Enrique de la Torre and Kenso Trabing and Matthew Treinish and TrishaPe and Davindra Tulsi and Wes Turner and Yotam Vaknin and Carmen Recio Valcarce and Francois Varchon and Almudena Carrera Vazquez and Victor Villar and Desiree Vogt-Lee and Christophe Vuillot and James Weaver and Johannes Weidenfeller and Rafal Wieczorek and Jonathan A. Wildstrom and Erick Winston and Jack J. Woehr and Stefan Woerner and Ryan Woo and Christopher J. Wood and Ryan Wood and Stephen Wood and Steve Wood and James Wootton and Daniyar Yeralin and David Yonge-Mallo and Richard Young and Jessie Yu and Christopher Zachow and Laura Zdanski and Helena Zhang and Christa Zoufal and Zoufalc and a-kapila and a-matsuo and bcamorrison and brandhsn and nick bronn and brosand and chlorophyll-zz and csseifms and dekel.meirom and dekelmeirom and dekool and dime10 and drholmie and dtrenev and ehchen and elfrocampeador and faisaldebouni and fanizzamarco and gabrieleagl and gadial and galeinston and georgios-ts and gruu and hhorii and hykavitha and jagunther and jliu45 and jscott2 and kanejess and klinvill and krutik2966 and kurarrr and lerongil and ma5x and merav-aharoni and michelle4654 and ordmoj and sagar pahwa and rmoyard and saswati-qiskit and scottkelso and sethmerkel and shaashwat and sternparky and strickroman and sumitpuri and tigerjack and toural and tsura-crisaldo and vvilpas and welien and willhbang and yang.luh and yotamvakninibm and Mantas {\v{C}}epulkovskis},
#        title = {Qiskit: An Open-source Framework for Quantum Computing},
#        year = {2019},
#        doi = {10.5281/zenodo.2562110}

# https://medium.com/@brcsomnath/qml-quantum-oracle-c8a48cdaf851
# https://jonathan-hui.medium.com/qc-quantum-computing-series-10ddd7977abd

# Curs detaliat de la Microsoft:
# https://youtu.be/F_Riqjdh2oM
# Inca un curs detaliat de la MIT:
# https://youtu.be/lZ3bPUKo5zc
# Cursul intreg de la MIT:
# https://ocw.mit.edu/courses/physics/8-04-quantum-physics-i-spring-2013/
# Si filmari: https://ocw.mit.edu/courses/physics/8-04-quantum-physics-i-spring-2013/lecture-videos/
# Exemplu lucrat. Cautarea unui nume intr-o lista de nume:

# https://quantumcomputing.stackexchange.com/questions/2149/grovers-algorithm-what-to-input-to-oracle
# Let me try to answer your question with a simple, direct answer:
#
# Q: Don't we need to input what we are looking for and where to find what we are looking for to Oracle,
# in addition to the superpositioned quantum states?
#
# No, you only need to have an oracle that outputs a 1 when it is provided with the correct answer
# and a 0 when provided with an incorrect answer.
#
# If you have a list that has the input names {"Alice", "Bob", "Corey", "Dio"}
# and you want to recognize the if the word Dio is on the list, then you need a way to encode the
# list's contents
# as input for the oracle. So the question is not what is on this list,
# the question is how many different inputs
# do you want to be able to encode? What is the total vocabulary?
#
# If there are 4 possible names (Alice, Bob, Corey and Dio), and you want to be able to encode any list
# with 4 of these names, then your input is four elements of two bits each: abcdefgh and the encoding
# is Alice=00, Bob=01, Corey=10 and Dio=11. You then would have an oracle
# that returns 1 if ab=11, cd=11, ef=11 or gh=11.
#
# If the inputs can be any 5-character string, encoded in 8-bit ASCII, then the input to the oracle
# is going to be 5×8×N where N is the maximum number of items that might be in your list.
# So the input could be quite large. However, the Oracle doesn't need to know all possible inputs;
# it merely needs to return 1 if any of the inputs contain "Dio" in any allowable position.

# https://qiskit.org/textbook/ch-algorithms/grover.html

# https://quantumcomputing.stackexchange.com/questions/16350/understanding-grovers-algorithm
# https://medium.com/analytics-vidhya/grovers-algorithm-in-python-c1dfa132e3af

# https://www.jetbrains.com/help/pycharm/enabling-version-control.html
# Sus de tot click pe VCS, apoi pe Enable Version Control Integration,
# selectare Git, apoi OK.
# Apoi de apasat la tastatura Alt si `, selectare Commit
# https://www.jetbrains.com/help/pycharm/adding-files-to-version-control.html#delete-from-repo

import qiskit
from qiskit import IBMQ, execute, QuantumRegister, ClassicalRegister, QuantumCircuit
from numpy import pi

from distributed import Client, LocalCluster, Worker, wait, progress

class GR3QuantumParallel(object):
    # def __init__(self, quantum_backend_name):
    #     self.quantum_backend_name = quantum_backend_name

    # Va fi apelat pe fiecare proces Dask
    def send_to_kingdom(self, quantum_backend_name):
        # IBMQ.save_account('e6bbad0f51ab787aec48bed242c422777f1680f0428e19b34e19bbcd467a2faff2bdcedd0cbb04b19f4bb700f66900728f778d4bc8226785e6c35dc818374ac8',
        #                   overwrite=True)
        provider = IBMQ.load_account()
        # print(IBMQ.providers())
        # print(IBMQ.get_provider(hub='ibm-q', group='open', project='main'))

        # backend = simulator = provider.get_backend('ibmq_qasm_simulator')
        # backend = simulator = provider.get_backend('ibmq_lima')
        backend = simulator = provider.get_backend(quantum_backend_name)



        # # CIRCUITS

        # #
        # https://qiskit.org/documentation/getting_started.html
        # # Create a Quantum Circuit acting on the q register
        # circuit = QuantumCircuit(2, 2)
        # # Add a H gate on qubit 0
        # circuit.h(0)
        # # Add a CX (CNOT) gate on control qubit 0 and target qubit 1
        # circuit.cx(0, 1)
        # # Map the quantum measurement to the classical bits
        # circuit.measure([0,1], [0,1])
        # #

        # #
        # https://quantum-computing.ibm.com/composer/docs/guide/grovers-algorithm
        # Grover pentru 00
        qreg_q = QuantumRegister(2, 'q')
        creg_c = ClassicalRegister(2, 'c')
        circuit = QuantumCircuit(qreg_q, creg_c)
        circuit.reset(qreg_q[0])
        circuit.reset(qreg_q[1])
        circuit.h(qreg_q[1])
        circuit.h(qreg_q[0])
        circuit.s(qreg_q[1])
        circuit.s(qreg_q[0])
        circuit.h(qreg_q[1])
        circuit.cx(qreg_q[0], qreg_q[1])
        circuit.s(qreg_q[0])
        circuit.h(qreg_q[1])
        circuit.h(qreg_q[0])
        circuit.s(qreg_q[1])
        circuit.x(qreg_q[0])
        circuit.h(qreg_q[1])
        circuit.x(qreg_q[1])
        circuit.h(qreg_q[1])
        circuit.cx(qreg_q[0], qreg_q[1])
        circuit.x(qreg_q[0])
        circuit.h(qreg_q[1])
        circuit.h(qreg_q[0])
        circuit.x(qreg_q[1])
        circuit.h(qreg_q[1])
        circuit.measure(qreg_q[0], creg_c[0])
        circuit.measure(qreg_q[1], creg_c[1])

        # https://qiskit.org/textbook/ch-algorithms/grover.html
        # circuit = self.initialize_s(self.prepare_quantum_circuit(2), [0, 1])

        # Execute the circuit on the qasm simulator
        job = execute(circuit, simulator, shots=1000)
        # #
        # https://medium.com/analytics-vidhya/grovers-algorithm-in-python-c1dfa132e3af
        #
        from qiskit.tools.monitor import job_monitor
        job_monitor(job, interval=2)
        # #

        # Grab results from the job
        result = job.result()

        # Returns counts
        counts = result.get_counts(circuit)
        # print("\nTotal count for 00 and 11 are:",counts)
        print("\nTotal count for 00, 01, 10 and 11 are:",counts)
        # 00, 01, 10 and 11 vin de la folosirea a doi qubits.
        # Pentru trei qubits avem: 000, 001, 010, 011,
        #                          100, 101, 110, 111
        # Posibila interpretare pentru text articol:
    # Starile 000, 001, 010, 011, 100, 101, 110, 111 ar fi graful data.
    # Pentru un exemplu 011 ar fi un query graph (cu numele 011,
    # conform
    # (1) https://quantumcomputing.stackexchange.com/questions/2149/grovers-algorithm-what-to-input-to-oracle
    # si
    # (2) https://quantumcomputing.stackexchange.com/questions/16350/understanding-grovers-algorithm).

    # Prin porti se influenteaza cresterea cat mai mare a
    # procentului probabilitatii starii 011, precum este afisat
    # in histogramele initiala si cea de dupa rulare al unui circuit.
    # Deocamdata nu ma ocup de encodarea si stocarea in oracol
    # al grafurilor. Stocarea in oracol al grafurilor cica nu este ok
    # in privinta algoritmului lui Grover, care si-ar pierde avantajul vitezei.
    #

    # Conform (1) precum a raspuns vy32, sirul abcdefgh este compus din 4 elemente a cate doi biti,
    # unde se verifica daca ab=11, cd=11, ef=11, gh=11 pt cazul cand este nevoie de Dio=11
    # Daca se folosesc elemente a cate trei biti (daca se folosesc trei qubits?) ar fi
    # verificarea daca abc=011, def=011, gh(s-ar adauga si i?), ghi=11, daca se face cautarea
    # dupa Dio=011?

    # De scris in articol despre folosirea grafurilor
    # query si data sub forma de matrice de adiacenta avand
    # elementele matricei valori 0 sau 1, si posibilitatea
    # de a le da ca si date de intrare pentru quantum.

    # Perspeciva pe care am mentionat-o la GR2 Algorithm la planurile de viitor:
    # Conform documentatiei IBM Quantum Experience (sau Qiskit, nu imi aduc aminte pe moment)
    # orice algoritm cu computatie clasica poate contine parti de Quantum Computing.

    # Titlu posibil:
    # The GR3 Algorithm for Parallel
    # Quantum Searching of Subgraph Isomorphism

    # #
    # https://stackoverflow.com/questions/18815820/how-to-convert-string-to-binary
    def encode_string_for_oracle(self, string_to_be_encoded):
        # binary_st = ' '.join(format(ord(x), 'b') for x in string_to_be_encoded)
        binary_st = ''.join(format(ord(x), 'b') for x in string_to_be_encoded)
        return binary_st
    # #

    # #
    # https://qiskit.org/textbook/ch-algorithms/grover.html
    def prepare_quantum_circuit(self, number_of_qubits):
        q_circuit = QuantumCircuit(number_of_qubits)
        return q_circuit
    def initialize_s(self, qc, qubits):
        """Apply a H-gate to 'qubits' in qc"""
        for q in qubits:
            qc.h(q)
        return qc
    # #


# https://github.com/dask/distributed/issues/2422
if __name__ == '__main__':
    lc = LocalCluster()
    lc.scale(10)
    client = Client(lc)

    gr3 = GR3QuantumParallel()
    future = client.submit(gr3.send_to_kingdom, 'ibmq_lima')
    # future2 = client.submit(gr3.send_to_kingdom, 'ibmq_qasm_simulator')

    # # https://stackoverflow.com/questions/41904987/is-it-possible-to-wait-until-persist-finishes-caching-in-dask
    # # http://distributed.readthedocs.io/en/latest/api.html#distributed.client.wait
    # # http://distributed.readthedocs.io/en/latest/api.html#distributed.diagnostics.progress
    wait([future])#, future2])
    # # progress([future, future2])
    future.result()
    # future2.result()

    # print(gr3.encode_string_for_oracle("John"))
    # print(gr3.encode_string_for_oracle("James"))

